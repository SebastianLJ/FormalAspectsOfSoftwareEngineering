NET
scheme TIMETABLE = extend NET with
class
  type 
    TimeTable = TramId -m-> Plan, -- time tables
    TramId = Text, -- tram names,
    PlanRow = StopId >< ArrivalT >< DepatureT,
    Plan = PlanRow-list,

    ArrivalT = Time, 
    DepatureT = Time

    value /* generators */
      -- the empty timetable
      empty : TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram : TramId >< TimeTable -> TimeTable
      addTram(tramid, timetable) is 
        timetable !! [tramid +> <..>],

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop : TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(tramid, stopid, arrival, departure, timetable) is
        timetable !! [tramid +> timetable(tramid) ^ <.(stopid, arrival, departure).>]

      -- Max capacity for a giving stop
   /*    findMaxCapacity : Time-list >< Time-list -> Int
      findMaxCapacity(arrivals, departures) is 
        len(arrs)
      pre len(arrs) = len(deps)
 */
  value /* observers */
    -- check whether a tram with a given name exists in a given time table
    isIn : TramId >< TimeTable -> Bool
    isIn(tramid, timetable) is
      tramid isin dom(timetable),

      nextStop : PlanRow >< Plan -~-> StopId
      nextStop(planRow, plan) is
        let
          iPlanRow = hd plan
        in
          if iPlanRow = planRow
          then 
            let 
              (sid, arrt, dept) = hd (tl plan)
            in 
              sid
            end
          else
            if len(tl plan) > 1
            then
              nextStop(planRow, tl plan)
            else
              let 
                (sid, arrt, dept) = iPlanRow
              in 
                sid
              end
            end
          end
        end
        pre len plan > 1,

      getConnection : StopId >< StopId >< Net -~-> Connection
      getConnection(stop1, stop2, (capacityMap, connectionMap)) is
      if (stop1, stop2) isin dom(connectionMap)
      then
        connectionMap((stop1, stop2))
      else
        connectionMap((stop2, stop1))
      end,
    -- you can add more observers here
    getAllDepaturesUsingConnection : StopId >< StopId >< TimeTable -> PlanRow-set
    getAllDepaturesUsingConnection(stopid1, stopid2, timetable) is
      let
        allPlans = rng(timetable)
      in
        buildAllDeparturesUsingConnection(stopid1, stopid2, allPlans)
      end,

    buildAllDeparturesUsingConnection : StopId >< StopId >< Plan-set -> PlanRow-set
    buildAllDeparturesUsingConnection(stopid1, stopid2, plans) is
      if plans = {}
      then {}
      else
        let
          plan = hd plans
        in
          {findDepartureRowInPlan(stopid1, stopid2, plan)} union buildAllDeparturesUsingConnection(stopid1, stopid2, plans \ {plan})
        end
      end,

    findDepartureRowInPlan : StopId >< StopId >< Plan -~-> PlanRow
    findDepartureRowInPlan(stopid1, stopid2, plan) is
      let
        (hStopId, hArrTime, hDepTime) = hd plan,
        nStopId = nextStop(hd plan, plan)
      in
        if hStopId = stopid1 /\ nStopId = stopid2
        then
          (hStopId, hArrTime, hDepTime)
        else
          if len tl plan > 1
          then
            findDepartureRowInPlan(stopid1, stopid2, tl plan)
          else
            ("", 0, 0)
          end
        end
      end
      pre len plan > 1,

    getAllArrivalsUsingConnection : StopId >< StopId >< TimeTable -> PlanRow-set
    getAllArrivalsUsingConnection(stopid1, stopid2, timetable) is
      let
        allPlans = rng(timetable)
      in
        buildAllArrivalsUsingConnection(stopid1, stopid2, allPlans)
      end,

    buildAllArrivalsUsingConnection : StopId >< StopId >< Plan-set -> PlanRow-set
    buildAllArrivalsUsingConnection(stopid1, stopid2, plans) is
      if plans = {}
      then {}
      else
        let
          plan = hd plans
        in
          {findArrivalRowInPlan(stopid1, stopid2, plan)} union buildAllArrivalsUsingConnection(stopid1, stopid2, plans \ {plan})
        end
      end,

    findArrivalRowInPlan : StopId >< StopId >< Plan -~-> PlanRow
    findArrivalRowInPlan(stopid1, stopid2, plan) is
      let
        (hStopId, hArrTime, hDepTime) = hd plan,
        (nStopId, nArrTime, nDepTime) = hd (tl plan)
      in
        if hStopId = stopid1 /\ nStopId = stopid2
        then
          (nStopId, nArrTime, nDepTime)
        else
          if len tl plan > 1
          then
            findArrivalRowInPlan(stopid1, stopid2, tl plan)
          else
            ("", 0, 0)
          end
        end
      end
      pre len plan > 1
 
  value /* predicates to check time tables */   


    -- every tram must have exactly one plan
    --  holds implicitly because TimeTable is mapping TramIds

    -- the travel times between each stop must be greater than or equal to the driving time
    timeBetweenStopsIsDrivingTime : Plan >< Net -~-> Bool
    timeBetweenStopsIsDrivingTime(plan, (capacityMap, connectionMap)) is
      if len plan > 1 then
        let
          (stopid1, arrTime1, depTime1) = hd plan,
          (stopid2, arrTime2, depTime2) = hd (tl plan)
        in
          let 
            (headway,drivingTime, capacity) = getConnection(stopid1, stopid2, (capacityMap, connectionMap))
          in
            (arrTime2 - depTime1 >= drivingTime) /\ timeBetweenStopsIsDrivingTime(tl plan, (capacityMap, connectionMap))
          end
        end
      else
        true
      end,

    -- the difference in departure times for any two trams moving on the same track must be greater than or equal to the headway time
    timeBetweenDeparturesIsValidHeadway : TimeTable >< Net -> Bool
    timeBetweenDeparturesIsValidHeadway(timetable, (capacityMap, connectionMap)) is
      (all (stopid1, stopid2) : StopId >< StopId :- (stopid1, stopid2) isin dom(connectionMap) =>
        let (headway,drivingTime, capacity) = connectionMap((stopid1, stopid2))
        in
          (all (sid1, arrt1, dept1) : PlanRow :- (sid1, arrt1, dept1) isin getAllDepaturesUsingConnection(stopid1, stopid2, timetable) =>
            (exists (sid2, arrt2, dept2) : PlanRow :- (sid2, arrt2, dept2) isin getAllDepaturesUsingConnection(stopid1, stopid2, timetable) \ {(sid1, arrt1, dept1)} /\
              (abs(dept1 - dept2) >= headway))
          )
        end
      ),
        

    -- the difference in arrival times for any two trams moving on the same track must be greater than or equal to the headway time
    -- a tram must stop at any stop it visits
    tramStopsAtAllStopsItPasses : TimeTable -> Bool
    tramStopsAtAllStopsItPasses(timetable) is
      (all tramid : TramId :- tramid isin dom(timetable) =>
        (all (stopid, arrTime, depTime) : PlanRow :- (stopid, arrTime, depTime) isin timetable(tramid) =>
          depTime - arrTime >= 1
        )
      ),

     -- the number of trains stopped at a stop must not exceed the capacity of the stop
/*      StopCapacityIsNotExceeded : Plan >< Net -> Bool
     StopCapacityIsNotExceeded(plan, net) is (all stopId : StopId :- stopId isin dom(planRow) =>
        let
           arrivals = ArrivalT,
           departures = DepartureT(plan(planRow(stopId)))
        in
           findMaxCapacity(arrivals, departures) <= capacity(stopId, net)
        end
      ),
 */
     -- the number of trains on a track must not exceed the capacity of the track

     isWellformed : TimeTable >< Net -~-> Bool
     isWellformed(t, n) is true
     
end  
