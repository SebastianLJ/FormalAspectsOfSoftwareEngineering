NET
scheme TIMETABLE = extend NET with
class
  type 
    TimeTable = TramId -m-> Plan, -- time tables
    TramId = Text, -- tram names
    PlanRow = StopId >< Time >< Time,
    Plan = PlanRow-list

    value /* generators */
      -- the empty timetable
      empty : TimeTable = [],

      -- add to a time table an empty plan for a new tram
      addTram : TramId >< TimeTable -> TimeTable
      addTram(tramid, timetable) is 
        timetable !! [tramid +> []],

      -- add a stop with arrival time and departure time to the plan for a given tram
      addStop : TramId >< StopId >< Time >< Time >< TimeTable -> TimeTable
      addStop(tramid, stopid, arrival, departure, timetable) is
        timetable !! [tramid +> timetable(tramid) ^ <.stopid, arrival, departure.>]

  value /* observers */
     -- check whether a tram with a given name exists in a given time table
     isIn : TramId >< TimeTable -> Bool
     isIn(tramid, timetable) is
       tramid isin dom(timetable),

      nextStop : PlanRow >< Plan -~-> stopId
      nextStop(planRow, plan) is
        let
          iPlanRow = hd plan
        in
          if iPlanRow = planRow
          then 
            hd (tl plan)
          else
            nextStop(planRow, tl plan)
          end
        end
      pre len plan > 1,

      getConnection : StopId >< StopId >< Net -> Connection
      getConnection(stop1, stop2, (capacityMap, connectionMap)) is
      if connectionMap((stop1, stop2)) = []
      then
        connectionMap((stop2, stop1))
      else
        connectionMap((stop1, stop2))
      end

     -- you can add more observers here

 
  value /* predicates to check time tables */   


    -- every tram must have exactly one plan
    --  holds implicitly because TimeTable is mapping TramIds

    -- the travel times between each stop must be greater than or equal to the driving time
    timeBetweenStopsIsDrivingTime : Plan >< Net -~-> Bool
    timeBetweenStopsIsDrivingTime(plan, net) is
      if len plan > 1 then
        let
          (stopid1, arrTime1, depTime1) = hd plan,
          (stopid2, arrTime2, depTime2) = hd (tl plan)
        in
          let 
            (headway,drivingTime, capacity) = getConnection(stopid1, stopid2, net)
          in
            (depTime1 - arrTime2 >= drivingTime) /\ timeBetweenStopsIsDrivingTime(tl plan)
          end
        end
      else
        true
      end,
    -- the difference in departure times for any two trams moving on the same track must be greater than or equal to the headway time
    timeBetweenDeparturesIsValidHeadway : TimeTable >< Net -> Bool
    timeBetweenDeparturesIsValidHeadway(timetable, (capacityMap, connectionMap)) is
      (all (stopid1, stopid2) : StopId >< StopId :- (stopid1, stopid2) isin dom(connectionMap) =>
        let (headway,drivingTime, capacity) = connectionMap((stopid1, stopid2))
        in
          (all plan: Plan :- plan isin rng(timetable) =>
            (all planRow : PlanRow :- planRow isin plan =>
              let 
                (stopid1, arrTime1, depTime1) = planRow
                (stopid2, arrTime2, depTime2) = nextStop(planRow, plan)
            )
          )
        end
        
      )

    -- the difference in arrival times for any two trams moving on the same track must be greater than or equal to the headway time
    -- a tram must stop at any stop it visits
    tramStopsAtAllStopsItPasses : TimeTable -> Bool
    tramStopsAtAllStopsItPasses(timetable) is
      (all tramid : TramId :- tramid isin dom(timetable) =>
        (all (stopid, arrTime, depTime) : PlanRow :- planRow isin timetable(tramid) =>
          depTime - arrTime >= 1
        )
      )

     TramsinStops : StopId >< TimeTable  -> Nat
     TramIds(stopid, timetable) is
        (all tramid : TramId :- tramid isin dom(timetable) =>
          (all (stopid, arrTime, depTime) : PlanRow :- planRow isin timetable(tramid) =>
            stopid = stopid
          )
        )


      
     -- the number of trains stopped at a stop must not exceed the capacity of the stop
     trainStopCapacity : CapacityMap >< TimeTable -> Bool
     trainStopCapacity(capacitymap, timetable) is 
        (all stopid : StopId :- stopid isin dom(capacitymap) =>
          (all tramid : TramId >< TramId :- tramid isin dom(timetable) =>
            (all (stopid, arrTime, depTime) : PlanRow :- planRow isin timetable(tramid) =>                

               (depTime - arrTime) <= capacity(stopid, net)
            )
          )
        )
     
    
     -- the number of trains on a track must not exceed the capacity of the track
     isWellformed : TimeTable >< Net -~-> Bool
     isWellformed(t, n) is ...,
     
end  
